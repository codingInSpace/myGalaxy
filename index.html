<!DOCTYPE html>
<html>
	<head>
		<title> Ships and satellites</title>
		<meta charset="utf-8">
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
		<!-- <script src="js/TrackballControls.js"></script> -->
		<script src="js/MTLLoader.js"></script>
		<script src="js/OBJMTLLoader.js"></script>
		<script src="js/OBJLoader.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script type="text/javascript" src="js/dat.gui.min.js"></script>
		
		<script>

		// Global variables
		var activePlanet;
		var activeMoon;
		var customTexture;
		var activeRotationSpeed;

		var clickableObjects = [];
		var planetGroups = [];
		var moonGroups = [];
		// var moons = [];

		var planets = [];		//multiarray of planet|moons
		var planetSpeeds = [];	//multiarray of planet|rotationSpeed
		var moonSpeeds = [];	//multiarray of moon|rotationSpeed

		var currentPlanet;					//render loop
		var currentMoon;					//render loop
		var currentRotationSpeed;			//render loop
		var planetNeedsInitialShift = false; //render loop
		var moonNeedsInitialShift = false;   //render loop

		var scene = new THREE.Scene();
		var camera = new THREE.PerspectiveCamera( 60, window.innerWidth/window.innerHeight, 0.1, 4000 );
		camera.position.z = 30;
		scene.add(camera);
		
		var renderer = new THREE.WebGLRenderer();
		renderer.setSize( window.innerWidth, window.innerHeight );
		document.body.appendChild( renderer.domElement );

		//Skapar en grupp som ska innehålla hela scengrafen
		sceneGraph = new THREE.Object3D;		
		
		var A_light = new THREE.AmbientLight( 0x404040 ); // soft white light
		sceneGraph.add( A_light );
		
		var light = new THREE.DirectionalLight( 0xffffff,0.7 );
		light.position.set( 20, 20, 20 ).normalize();
		sceneGraph.add(light);

		// Sun
		sunGroup =new THREE.Object3D;
		var sunGeometry = new THREE.SphereGeometry( 10, 32, 32 );
		var sunMaterial = new THREE.MeshPhongMaterial();
		sunMaterial.map    = THREE.ImageUtils.loadTexture('textures/suntexture.jpg');
		sunMaterial.bumpMap    = THREE.ImageUtils.loadTexture('textures/suntexture.jpg');
		sunMaterial.bumpScale = 0.06;
		sunMaterial.specular  = new THREE.Color('grey');
		var sunSphere = new THREE.Mesh( sunGeometry, sunMaterial );
		// sunGroup.add(sunSphere);
		scene.add(sunSphere);


		/******* GUI *******/
        var gui = new dat.GUI();

		var parameters = {
			addPlanet: function() { addPlanet() },
			radius: 30,
			size: 1,
			rotation: 0.01,
			texture1: function() { updatePlanetTexture("Earth") },
			texture2: function() { updatePlanetTexture("Cloudy") },
			texture3: function() { updatePlanetTexture("Steel") },
			texture4: function() { updatePlanetTexture("Terraformed mars") },
			texture5: function() { updatePlanetTexture("Alien") },
			texture6: function() { updatePlanetTexture("Desolate") },
			texture7: function() { updatePlanetTexture("Sandy") },
			texture8: function() { updatePlanetTexture("Klendathu") },
			texture9: function() { updatePlanetTexture() },
			addMoon: function() { addMoon() },
			moonRotation: 0.01,
			moonRadius: 10
		};

		gui.add( parameters, 'addPlanet').name("Spawn new planet");
		
		// planet properties
		var planetPropertiesFl = gui.addFolder('Planet properties');
		var sphereRadius = planetPropertiesFl.add( parameters, 'radius',0 ).min(30).max(300).step(1).listen();
		var sphereSize = planetPropertiesFl.add( parameters, 'size' ).min(0.5).max(5).step(0.1).listen(); 
		var planetRotation = planetPropertiesFl.add(parameters, 'rotation').min(0.001).max(0.050).step(0.001).listen(); 
		planetPropertiesFl.open();

		// planet textures
		var planetTexturesFl = gui.addFolder('Planet textures');
		planetTexturesFl.add( parameters, 'texture1' ).name("Earth");
		planetTexturesFl.add( parameters, 'texture2' ).name("Cloudy");
		planetTexturesFl.add( parameters, 'texture3' ).name("Steel");
		planetTexturesFl.add( parameters, 'texture4' ).name("Terraformed mars");
		planetTexturesFl.add( parameters, 'texture5' ).name("Alien");
		planetTexturesFl.add( parameters, 'texture6' ).name("Desolate");
		planetTexturesFl.add( parameters, 'texture7' ).name("Sandy");
		planetTexturesFl.add( parameters, 'texture8' ).name("Klendathu");
		planetTexturesFl.add( parameters, 'texture9' ).name("Scarl");

		var moonPropertiesFl = gui.addFolder('Moons');
		moonPropertiesFl.add( parameters, 'addMoon' ).name("Spawn moon");
		var moonRotation = moonPropertiesFl.add(parameters, 'moonRotation').min(0.001).max(0.050).step(0.001).listen(); 
		var moonRadius = moonPropertiesFl.add( parameters, 'moonRadius',0 ).min(5).max(50).step(1).listen();

		sphereRadius.onChange(function(value) 
		{   activePlanet.position.x = value;   });
		
		sphereSize.onChange(function(value) {
			activePlanet.scale.x = value;
			activePlanet.scale.y = value;
			activePlanet.scale.z = value;
		});
		
		planetRotation.onChange(function(value) {
			for (var i = 0; i < planetSpeeds.length; ++i) {
				if (planetSpeeds[i][0] == activePlanet) {	//where first element is active planet
					planetSpeeds[i][1] = value;		//change second element to slider value
					// console.log("rotation changed to " + value);
				}
			}
		});

		moonRadius.onChange(function(value) 
		{   activeMoon.position.x = value;   });

		moonRotation.onChange(function(value) {
			for (var i = 0; i < moonSpeeds.length; ++i) {
				if (moonSpeeds[i][0] == activeMoon) {	//where first element is active planet
					moonSpeeds[i][1] = value;		//change second element to slider value
					// console.log("rotation changed to " + value);
				}
			}
		});

		gui.open();

		/*******************/

        /****** NORMANDY *******/
		var normandyOnProgress = function ( xhr ) {
            if ( xhr.lengthComputable ) {
                var percentComplete = xhr.loaded / xhr.total * 100;
                console.log( Math.round(percentComplete, 2) + '% of Normandy downloaded' );
            }
        };

        var onError = function ( xhr ) {
			console.log( 'Error loading Normandy' );
        };

        var loader = new THREE.OBJLoader();
        var normandy;
        loader.load( "normandy/normandy4.obj", function(normandy){ 
            normandy.scale.x = 0.02;
            normandy.scale.y = 0.02;
            normandy.scale.z = 0.02;

            normandy.position.x = 20;
            normandy.rotation.x = -Math.PI / 2;
         
            sunSphere.add(normandy);
        },normandyOnProgress, onError);
        /************************/


		galaxyGroup = new THREE.Object3D;
		var galaxyGeometry = new THREE.SphereGeometry( 1500, 32, 32 );
		var galaxyMaterial = new THREE.MeshPhongMaterial();
		galaxyMaterial.map = THREE.ImageUtils.loadTexture('textures/Starfield_by_meliad.jpg');
		galaxyMaterial.side = THREE.DoubleSide;
		var galaxySphere = new THREE.Mesh( galaxyGeometry, galaxyMaterial );
		
		galaxyGroup.add(galaxySphere);			
		sceneGraph.add(galaxyGroup);

		//Lägger till grupper till scengraf
		galaxyGroup.add(sunSphere);
		
		//Lägger till scengraf till scen
		scene.add(sceneGraph);
		sceneGraph.rotation.x += 0.5;
		
		controls = new THREE.OrbitControls( camera, renderer.domElement );

		window.addEventListener( 'resize', onWindowResize, false );
		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize( window.innerWidth, window.innerHeight );
		}
		
		function addPlanet(){
			var sphereGeometry = new THREE.SphereGeometry( 5, 32, 32 );
			var sphereMaterial = new THREE.MeshLambertMaterial();

			activePlanet = new THREE.Mesh(sphereGeometry, sphereMaterial);
			var activeGroup = new THREE.Object3D;
			activeGroup.position.x = 0;
			activeRotationSpeed = 0.01;
			planetNeedsInitialShift = true;

			// sunGroup.add(activeGroup);
			activeGroup.add(activePlanet);
			clickableObjects.push(activePlanet);
			planetGroups.push(activeGroup);

			// Add planet group (and missing ones if exist) to sungroup
			for (var i = 0; i < planetGroups.length; ++i) {
			    if (planetGroups[i].parent !== sunSphere){
			    	sunSphere.add(planetGroups[i]);
			    	console.log("new planet group added to sun")
			    }
			}

			// Push planet object + rotationSpeed
			tempArray = [activePlanet, activeRotationSpeed];
			planetSpeeds.push(tempArray);

			//push to planets
			tempArray = [activePlanet];
			planets.push(tempArray);

		}
		
		function updatePlanetTexture(textureName){
			var value = textureName;
			var newMaterial;

			if (value == "Earth") {
				newMaterial = new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'textures/earthmap.jpg' )} );
				console.log('earth selected');
			} else if (value == "Cloudy") {
				newMaterial = new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'textures/cloudy.jpg' )} );
				console.log('cloudy selected');
			} else if (value == "Steel") {
				newMaterial = new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'textures/steeltexture.jpg' )} );
				console.log('steel selected');
			} else if (value == "Terraformed mars") {
				newMaterial = new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'textures/terramars.jpg' )} );
				console.log('terramars selected');
			} else if (value == "Alien") {
				newMaterial = new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'textures/alien.jpg' )} );
				console.log('alien selected');
			} else if (value == "Desolate") {
				newMaterial = new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'textures/desolate.png' )} );
				console.log('desolate selected');
			} else if (value == "Sandy") {
				newMaterial = new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'textures/sandy.jpg' )} );
				console.log('sandy selected');
			} else if (value == "Klendathu") {
				newMaterial = new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'textures/klendathu.png' )} );
				console.log('klendathu selected');
			} else { //Scarl
				newMaterial = new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'textures/scarl.png' )} );
				console.log('scarl selected');
			}

			activePlanet.material = newMaterial;
			activePlanet.material.needsUpdate = true;
			activePlanet.texture.needsUpdate = true;	//gives error output but works anyway
			
			// activePlanet.position.x = parameters.x;

			// activePlanet.position.y = parameters.y;
			// activePlanet.position.z = parameters.z;
			// activePlanet.material.color.setHex( parameters.color.replace("#", "0x") );
			// activePlanet.material.opacity = parameters.opacity;  
			// activePlanet.material.transparent = true;
			// activePlanet.visible = parameters.visible;
		}

		function addMoon() {
			var sphereGeometry = new THREE.SphereGeometry( 2, 16, 16 );
			var sphereMaterial = new THREE.MeshLambertMaterial();

			activeMoon = new THREE.Mesh(sphereGeometry, sphereMaterial);
			var activeGroup = new THREE.Object3D;
			activeGroup.add(activeMoon);

			activeMoon.position.x = 0;
			activeRotationSpeed = 0.01;
			moonNeedsInitialShift = true;

			clickableObjects.push(activeMoon);
			// activePlanet.add(activeMoon);
			activePlanet.add(activeGroup);
			moonGroups.push(activeGroup);

			// put moon to corresponding planet in array
			for (var i = 0; i < planets.length; ++i) {
				if (planets[i][0] == activePlanet) {
					planets[i].push(activeMoon)
					// console.log("current planet received a moon");
				}
			}

			// Push moon object + rotationSpeed
			tempArray = [activeMoon, activeRotationSpeed];
			moonSpeeds.push(tempArray);

			console.log("moon spawned");
		}

		// click functionality
		var raycaster = new THREE.Raycaster();
		var intersects = raycaster.intersectObjects( clickableObjects );	
		var mouse = new THREE.Vector2();
		document.addEventListener( 'mousedown', onDocumentMouseDown, false );
		document.addEventListener( 'touchstart', onDocumentTouchStart, false );

		function onDocumentTouchStart( event ) {	
			event.preventDefault();
			
			event.clientX = event.touches[0].clientX;
			event.clientY = event.touches[0].clientY;
			onDocumentMouseDown( event );
		}	
		
		function onDocumentMouseDown( event ) {
			console.log("mouse is down");

			event.preventDefault();
			mouse.x = ( event.clientX / renderer.domElement.width ) * 2 - 1;
			mouse.y = - ( event.clientY / renderer.domElement.height ) * 2 + 1;
			raycaster.setFromCamera( mouse, camera );
			intersects = raycaster.intersectObjects( clickableObjects );

			if ( intersects.length > 0 ) {
				console.log("we have an intersect");
				activePlanet = intersects[0].object;
			}
		}

		//render loop
		var render = function () {
			requestAnimationFrame( render );
			controls.update();

			// sun rotation
			sunSphere.rotation.z += 0.01;

			if (planetNeedsInitialShift) {
				activePlanet.position.x += 30;
				planetNeedsInitialShift = false;
				console.log("planet shifted");
			}
			if (moonNeedsInitialShift) {	//kolla om nödvändigt när alla rotationer finns
				activeMoon.position.x += 10;
				moonNeedsInitialShift = false;
				console.log("moon shifted");
			}

			// planet rotation speeds about sun
			for (var i = 0; i < planetSpeeds.length; ++i) {
				currentPlanetGroup = planetSpeeds[i][0].parent;
				currentRotationSpeed = planetSpeeds[i][1];

				currentPlanetGroup.rotation.z += currentRotationSpeed;
			}

			// planet rotations about self (ha som variabel?)
			for (var i = 0; i < planets.length; ++i) {
				planets[i][0].rotation.z += 0.03;
			}

			// moon rotation speeds about sun
			for (var i = 0; i < moonSpeeds.length; ++i) {
				currentMoonGroup = moonSpeeds[i][0].parent;
				currentRotationSpeed = moonSpeeds[i][1];

				currentMoonGroup.rotation.z += currentRotationSpeed;
			}
			
			renderer.render(scene, camera);
		};

		render();
		</script>
	</body>
</html>
