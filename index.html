<!DOCTYPE html>
<html>
	<head>
		<title>Sammansatt branch</title>
		<meta charset="utf-8">
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
		<!-- <script src="js/TrackballControls.js"></script> -->
		<script src="js/MTLLoader.js"></script>
		<script src="js/OBJMTLLoader.js"></script>
		<script src="js/OBJLoader.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script type="text/javascript" src="js/dat.gui.min.js"></script>
		<script src="js/TrackballControls.js"></script>


		<script id="vertexShader" type="x-shader/x-vertex">	
			varying vec3 vNormal;
			void main() {
			    vNormal = normalize( normalMatrix * normal );
			    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 0.9 );
			}
		</script>


		<script id="fragmentShader" type="x-shader/x-vertex">			 
			varying vec3 vNormal;
			void main() {
				float intensity = pow( 0.65 - dot( vNormal, vec3( 0.0, 0.0, 0.5 ) ), 7.0 ); 
			    gl_FragColor = vec4( 1.0, 0.8, 0.5, 1.0 ) * intensity;
			}
		</script>

		<script id="fragmentShader2" type="x-shader/x-vertex">			 
			varying vec3 vNormal;
			void main() {
				float intensity = pow( 0.7 - dot( vNormal, vec3( 0.0, 0.0, 0.5 ) ), 7.0 ); 
			    gl_FragColor = vec4( 0.2, 0.4, 0.5, 1.0 ) * intensity;
			}
		</script>
		
		<script>

		// Basic global variables
		var container, camera, scene, renderer;

		// Meshes for planets
		var sunSphere;

		// Variables to be used for current object to be changed
		var activePlanet;
		var activeMoon;
		var customTexture;
		var activeRotationSpeed;

		// Array of all objects to be clickable
		var clickableObjects = [];

		// Groups for objects
		var planetGroups = [];
		var moonGroups = [];

		// Multiarrays to keep track of things that correspond to each other 
		var planets = [];		//multiarray of planet|moons
		var planetSpeeds = [];	//multiarray of planet|rotationSpeed
		var moonSpeeds = [];	//multiarray of moon|rotationSpeed

		// Variables for render loop
		var currentPlanet;					
		var currentMoon;					
		var currentRotationSpeed;			
		var planetNeedsInitialShift = false;
		var moonNeedsInitialShift = false;  

		// click functionality
		var raycaster = new THREE.Raycaster();		
		var intersects = raycaster.intersectObjects( clickableObjects );	
		var mouse = new THREE.Vector2();
		document.addEventListener( 'mousedown', onDocumentMouseDown, false );
		document.addEventListener( 'touchstart', onDocumentTouchStart, false );

		init();
		animate();

		function init() {
			scene = new THREE.Scene();
			scene.fog = new THREE.Fog( 0x000000, 3500, 15000 );
			scene.fog.color.setHSL( 0.51, 0.4, 0.01 );
			camera = new THREE.PerspectiveCamera( 60, window.innerWidth/window.innerHeight, 0.1, 20000 );
			camera.position.z = 30;
			scene.add(camera);
			
			renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
			renderer.setClearColor( scene.fog.color );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );

			renderer.gammaInput = true;
			renderer.gammaOutput = true;
			
			var ambientLight = new THREE.AmbientLight( 0xffffff ); // soft white light
			ambientLight.color.setHSL( 0.1, 0.3, 0.2 );
			scene.add( ambientLight );
			
			var dirLight = new THREE.DirectionalLight( 0xffffff, 0.125 );
			dirLight.position.set( 0, -1, 0 ).normalize();
			scene.add(dirLight);

			/************* SUN ****************/
			/* create custom material from the shader code above
			that is within specially labeled script tags */
			var customSunMaterial = new THREE.ShaderMaterial( {
			    uniforms: {  },
				vertexShader:   document.getElementById( 'vertexShader'   ).textContent,
				fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
				side: THREE.BackSide,
				blending: THREE.AdditiveBlending,
				transparent: true
			}   );
				
			var sunGeometry = new THREE.SphereGeometry( 9, 32, 16 );
			sunSphere = new THREE.Mesh( sunGeometry, customSunMaterial );
			scene.add(sunSphere);

			//Origo
			addLight( 0.55, 0.9, 0.5, 1, 1, 1 );
			addLight( 0.08, 0.8, 0.5, 2, 2, 2 );


			/******* GUI *******/
	        var gui = new dat.GUI();

			var parameters = {
				addPlanet: function() { addPlanet() },
				radius: 30,
				size: 1,
				rotation: 0.001,
				texture1: function() { updatePlanetTexture("Earth") },
				texture2: function() { updatePlanetTexture("Cloudy") },
				texture3: function() { updatePlanetTexture("Steel") },
				texture4: function() { updatePlanetTexture("Terraformed mars") },
				texture5: function() { updatePlanetTexture("Alien") },
				texture6: function() { updatePlanetTexture("Desolate") },
				texture7: function() { updatePlanetTexture("Sandy") },
				texture8: function() { updatePlanetTexture("Klendathu") },
				texture9: function() { updatePlanetTexture() },
				addMoon: function() { addMoon() },
				moonRadius: 10,
				moonRotation: 0.001
			};

			gui.add( parameters, 'addPlanet').name("Spawn new planet");
			
			// planet properties
			var planetPropertiesFl = gui.addFolder('Planet properties');
			var sphereRadius = planetPropertiesFl.add( parameters, 'radius',0 ).min(30).max(300).step(1).listen();
			var sphereSize = planetPropertiesFl.add( parameters, 'size' ).min(0.5).max(5).step(0.1).listen(); 
			var planetRotation = planetPropertiesFl.add(parameters, 'rotation').min(0.001).max(0.0100).step(0.001).listen(); 
			planetPropertiesFl.open();

			// planet textures
			var planetTexturesFl = gui.addFolder('Planet textures');
			planetTexturesFl.add( parameters, 'texture1' ).name("Earth");
			planetTexturesFl.add( parameters, 'texture2' ).name("Cloudy");
			planetTexturesFl.add( parameters, 'texture3' ).name("Steel");
			planetTexturesFl.add( parameters, 'texture4' ).name("Terraformed mars");
			planetTexturesFl.add( parameters, 'texture5' ).name("Alien");
			planetTexturesFl.add( parameters, 'texture6' ).name("Desolate");
			planetTexturesFl.add( parameters, 'texture7' ).name("Sandy");
			planetTexturesFl.add( parameters, 'texture8' ).name("Klendathu");
			planetTexturesFl.add( parameters, 'texture9' ).name("Scarl");

			var moonPropertiesFl = gui.addFolder('Moons');
			moonPropertiesFl.add( parameters, 'addMoon' ).name("Spawn moon");
			var moonRadius = moonPropertiesFl.add( parameters, 'moonRadius',0 ).min(5).max(50).step(1).listen();
			var moonRotation = moonPropertiesFl.add(parameters, 'moonRotation').min(0.001).max(0.010).step(0.001).listen(); 

			sphereRadius.onChange(function(value) 
			{   activePlanet.position.x = value;   });
			
			sphereSize.onChange(function(value) {
				activePlanet.scale.x = value;
				activePlanet.scale.y = value;
				activePlanet.scale.z = value;
			});
			
			planetRotation.onChange(function(value) {
				for (var i = 0; i < planetSpeeds.length; ++i) {
					if (planetSpeeds[i][0] == activePlanet) {	//where first element is active planet
						planetSpeeds[i][1] = value;		//change second element to slider value
						// console.log("rotation changed to " + value);
					}
				}
			});

			moonRadius.onChange(function(value) 
			{   activeMoon.position.x = value;   });

			moonRotation.onChange(function(value) {
				for (var i = 0; i < moonSpeeds.length; ++i) {
					if (moonSpeeds[i][0] == activeMoon) {	//where first element is active planet
						moonSpeeds[i][1] = value;		//change second element to slider value
						// console.log("rotation changed to " + value);
					}
				}
			});

			gui.open();
			/*******************/
			
			controls = new THREE.OrbitControls( camera, renderer.domElement );
		
		}	//end init

		function addLight( h, s, l, x, y, z ) {
			var light = new THREE.PointLight( 0xffffff, 1.5, 0 );
			light.color.setHSL( h, s, l );
			light.position.set( x, y, z );
			scene.add( light );

			var flareColor = new THREE.Color( 0xffffff );
			flareColor.setHSL( h, s, l + 0.3 );

			var textureFlare0 = THREE.ImageUtils.loadTexture( "textures/lensflare/lensflare0.png" );

			var lensFlare = new THREE.LensFlare( textureFlare0, 900, 0.0, THREE.AdditiveBlending, flareColor );

			lensFlare.customUpdateCallback = lensFlareUpdateCallback;
			//lensFlare.position.copy( light.position );

			scene.add( lensFlare );
		}

		window.addEventListener( 'resize', onWindowResize, false );
		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize( window.innerWidth, window.innerHeight );
		}
		
		function addPlanet(){
			var atmosphereGeometry = new THREE.SphereGeometry( 11, 32, 32 );

			var atmosphereMaterial = new THREE.ShaderMaterial( {
			    uniforms: {  },
				vertexShader:   document.getElementById( 'vertexShader'   ).textContent,
				fragmentShader: document.getElementById( 'fragmentShader2' ).textContent,
				side: THREE.BackSide,
				blending: THREE.AdditiveBlending,
				transparent: true
			}   );

			var atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
			
			var sphereGeometry = new THREE.SphereGeometry( 11, 32, 32 );
			var sphereMaterial = new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'textures/earthmap.jpg' )} );
			activePlanet = new THREE.Mesh(sphereGeometry, sphereMaterial);

			activePlanet.add(atmosphere);

			var activeGroup = new THREE.Object3D;
			activeGroup.position.x = 0;
			activeRotationSpeed = 0.00001;
			planetNeedsInitialShift = true;

			// sunGroup.add(activeGroup);
			activeGroup.add(activePlanet);
			clickableObjects.push(activePlanet);
			planetGroups.push(activeGroup);

			// Add planet group (and missing ones if exist) to sungroup
			for (var i = 0; i < planetGroups.length; ++i) {
			    if (planetGroups[i].parent !== sunSphere){
			    	sunSphere.add(planetGroups[i]);
			    	console.log("new planet group added to sun")
			    }
			}

			// Push planet object + rotationSpeed
			tempArray = [activePlanet, activeRotationSpeed];
			planetSpeeds.push(tempArray);

			//push to planets
			tempArray = [activePlanet];
			planets.push(tempArray);

		}
		
		function updatePlanetTexture(textureName){
			var value = textureName;
			var newMaterial;

			if (value == "Earth") {
				newMaterial = new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'textures/earthmap.jpg' )} );
				console.log('earth selected');
			} else if (value == "Cloudy") {
				newMaterial = new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'textures/cloudy.jpg' )} );
				console.log('cloudy selected');
			} else if (value == "Steel") {
				newMaterial = new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'textures/steeltexture.jpg' )} );
				console.log('steel selected');
			} else if (value == "Terraformed mars") {
				newMaterial = new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'textures/terramars.jpg' )} );
				console.log('terramars selected');
			} else if (value == "Alien") {
				newMaterial = new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'textures/alien.jpg' )} );
				console.log('alien selected');
			} else if (value == "Desolate") {
				newMaterial = new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'textures/desolate.png' )} );
				console.log('desolate selected');
			} else if (value == "Sandy") {
				newMaterial = new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'textures/sandy.jpg' )} );
				console.log('sandy selected');
			} else if (value == "Klendathu") {
				newMaterial = new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'textures/klendathu.png' )} );
				console.log('klendathu selected');
			} else { //Scarl
				newMaterial = new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'textures/scarl.png' )} );
				console.log('scarl selected');
			}

			activePlanet.material = newMaterial;
			// activePlanet.material.needsUpdate = true;
			// activePlanet.material.map.needsUpdate = true;
			activePlanet.texture.needsUpdate = true;	//gives error output but works anyway
		}

		function addMoon() {
			var atmosphereGeometry = new THREE.SphereGeometry( 4, 32, 32 );

			var atmosphereMaterial = new THREE.ShaderMaterial( {
			    uniforms: {  },
				vertexShader:   document.getElementById( 'vertexShader'   ).textContent,
				fragmentShader: document.getElementById( 'fragmentShader2' ).textContent,
				side: THREE.BackSide,
				blending: THREE.AdditiveBlending,
				transparent: true
			}   );

			var atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
			
			var sphereGeometry = new THREE.SphereGeometry( 4, 32, 32 );
			var sphereMaterial = new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture( 'textures/moontexture.jpg' )} );
			activeMoon = new THREE.Mesh(sphereGeometry, sphereMaterial);

			activeMoon.add(atmosphere);
			var activeGroup = new THREE.Object3D;
			activeGroup.add(activeMoon);

			activeMoon.position.x = 0;
			activeRotationSpeed = 0.001;
			moonNeedsInitialShift = true;

			clickableObjects.push(activeMoon);
			// activePlanet.add(activeMoon);
			activePlanet.add(activeGroup);
			moonGroups.push(activeGroup);

			// put moon to corresponding planet in array
			for (var i = 0; i < planets.length; ++i) {
				if (planets[i][0] == activePlanet) {
					planets[i].push(activeMoon)
					// console.log("current planet received a moon");
				}
			}

			// Push moon object + rotationSpeed
			tempArray = [activeMoon, activeRotationSpeed];
			moonSpeeds.push(tempArray);

			console.log("moon spawned");
		}

		function onDocumentTouchStart( event ) {	
			event.preventDefault();
			event.clientX = event.touches[0].clientX;
			event.clientY = event.touches[0].clientY;
			onDocumentMouseDown( event );
		}	
		
		function onDocumentMouseDown( event ) {
			console.log("mouse is down");

			event.preventDefault();
			mouse.x = ( event.clientX / renderer.domElement.width ) * 2 - 1;
			mouse.y = - ( event.clientY / renderer.domElement.height ) * 2 + 1;
			raycaster.setFromCamera( mouse, camera );
			intersects = raycaster.intersectObjects( clickableObjects );

			if ( intersects.length > 0 ) {
				console.log("we have an intersect");
				var clickedObject = intersects[0].object;

				for (var i = 0; i < planetGroups.length; i++) {
					if (clickedObject.parent == planetGroups[i]) {
						activePlanet = clickedObject;
						console.log("clicked object is a planet");
					}
				}

				for (var i = 0; i < moonGroups.length; i++) {
					if (clickedObject.parent == moonGroups[i]) {
						activeMoon = clickedObject;
						console.log("clicked object is a moon");
					}
				}
			}
		}

		function lensFlareUpdateCallback( object ) {
		    var f, fl = this.lensFlares.length;
		    var flare;
		    var vecX = -this.positionScreen.x * 2;
		    var vecY = -this.positionScreen.y * 2;
		    var camDistance = camera.position.length();

		    for( f = 0; f < fl; f ++ ) {

		        flare = this.lensFlares[ f ];

		        flare.x = this.positionScreen.x + vecX * flare.distance;
		        flare.y = this.positionScreen.y + vecY * flare.distance;

		        flare.wantedRotation = flare.x * Math.PI * 0.25;
		        flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

		        flare.scale = 1 / camDistance * 200;
		    }

		}

		function animate() {
			requestAnimationFrame( animate );
			controls.update();

			render();	
		}

		function render() {
			// console.log("render check");

			// sun rotation
			sunSphere.rotation.z += 0.0001;

			if (planetNeedsInitialShift) {
				activePlanet.position.x += 60;
				planetNeedsInitialShift = false;
				console.log("planet shifted");
			}
			if (moonNeedsInitialShift) {	//kolla om nödvändigt när alla rotationer finns
				activeMoon.position.x += 20;
				moonNeedsInitialShift = false;
				console.log("moon shifted");
			}

			// planet rotation speeds about sun
			for (var i = 0; i < planetSpeeds.length; ++i) {
				currentPlanetGroup = planetSpeeds[i][0].parent;
				currentRotationSpeed = planetSpeeds[i][1];

				currentPlanetGroup.rotation.z += currentRotationSpeed;
			}

			// planet rotations about self (ha som variabel?)
			for (var i = 0; i < planets.length; ++i) {
				planets[i][0].rotation.z += 0.005;
			}

			// moon rotation speeds about sun
			for (var i = 0; i < moonSpeeds.length; ++i) {
				currentMoonGroup = moonSpeeds[i][0].parent;
				currentRotationSpeed = moonSpeeds[i][1];

				currentMoonGroup.rotation.z += currentRotationSpeed;
			}
			
			renderer.render(scene, camera);
		}

		</script>
	</body>
</html>
